## 로그인 상태관리 도입에 대한 고찰

애플리케이션의 상태를 중앙에서 관리하는 것<br/>
다양한 부분에서 상태를 쉽게 공유하고 업데이트 가능

### 현재 코드 동작 방식

App.tsx 파일에서 storage, authChange라는 이벤트를 감지함

1. storage 이벤트

- localStorage에 변화가 생겼을 때 발생하는 이벤트(브라우저 내장)
- 다른 탭에서 localStorage가 변경되었을 경우 발생
- 같은 탭에서는 발생X

2. authChange 이벤트

- 로그아웃, 탈퇴 시 발생하는 이벤트(커스텀 이벤트)

```typescript
const handleStorageChange = () => {
  const token = localStorage.getItem('accessToken')
  setIsLoggedIn(!!token)
}

window.addEventListener('storage', handleStorageChange)

const handleCustomStorageChange = () => {
  const token = localStorage.getItem('accessToken')
  setIsLoggedIn(!!token)
}

window.addEventListener('authChange', handleCustomStorageChange)
```

각각 이벤트를 감지해서 로그인 상태 `setIsLoggedIn`를 세팅함

만약 로그인을 해서 `localStorage.setItem('accessToken', response.data.accessToken)`을 했다면<br/>
`localStorage`에 변화가 생겼으니 브라우저 내장 이벤트인 `storage` 이벤트가 발생<br/>
`App.tsx`에서는 이벤트 핸들러로 storage 이벤트 감지 후 `setIsLoggedIn` 상태를 업데이트<br/>

로그아웃 혹은 탈퇴시에는 `window.dispatchEvent(new Event('authChange'))`<br/>
`authChange`라는 커스텀 이벤트를 발생시켜서 setLoggedIn 상태를 업데이트

### 왜 생각했는지?

이벤트 감지로 로그인 상태를 업데이트 하는 로직을 다른 팀원이 작성하고<br/>
내가 회원 탈퇴 기능을 작성했는데 동작이 제대로 되지 않았고 추후에 authChange 이벤트 발생시키는 코드가 필요하다는 것을 알게됨

### 개선이 필요하다고 생각한 이유

1. 통일성 부족

- 이벤트 기반으로 로그인 상태를 관리하면 로직마다 해당 이벤트 발생을 적어줘야함
- 로직에 대한 통일성이 필요하다고 생각했고, 여러 곳에서 함꼐 공유하는 상태인 로그인을 전역으로 관리하는 것이 필요하다고 생각함

2. 코드 반복

- 인증과 관련된 로직을 작성할때마다 `localStorage.setItem()`, `localStorage.getItem()`과 같이 반복되는 코드 작성을 줄이고 싶다고 생각.

3. 상태 관리 분산

- 로그인 상태를 업데이트하는 로직이 분산되어 있음
- 이벤트를 실수로 작성하지 않거나 잘못 처리할 가능성 존재

4. 강제 리다이렉트

- 토큰 만료 시 해당 로직을 사용하고 있음 `window.location.href = '/login'`
- 위 방식은 브라우저 전체를 새로고침하는 것
- 그럴거면 SPA를 왜 쓰나요...

### 그래서

상태관리를 도입하면 어떨까?
<br/>
상태 관리 : 컴포넌트들의 상태를 애플리케이션 전역에서 효율적으로 관리하는 기술 또는 패턴
<br/>
<br/>
로그인 여부는 애플리케이션 전역에서 공통으로 사용되는 클라이언트 상태임<br/>
(클라이언트 상태 : 서버가 아니라 클라이언트에서 관리하는 상태, 서버에서 받아오지 않아도 브라우저에서 관리 가능)<br/>

상태 관리 라이브러리 사용을 통해 로그인 상태를 관리하면 한 곳에서 로그인 상태를 전역으로 관리 가능<br/>
한 군데에서 로그인 상태를 모두 관리하기 때문에 내가 느낀 통일성 부족, 코드 반복, 상태 관리 분산 이 3가지 점을 개선할 수 있을 것이라 생각

### 도입했을 때의 이점

1. 전역 상태 공유

- 어디서든 로그인 상태 접근 가능
- 로그인 상태와 관련한 로직이 하나로 관리됨

2. 반복 코드 제거

- 로직이 스토어에 작성되기 때문에 사용하기 간편&일관성 유지

3. 토큰 만료 여부 확인 가능

- 현재 토큰 재발급 함수는 api 요청 시점에서 체크 (401 에러를 반환받아야지 실행됨)
- 따라서 실시간 갱신이 어려움
- 최상위 컴포넌트에서 `setInterval` 사용으로 토큰 만료 체크 가능

### 근데 지금 도입해도 괜찮을까?

프로젝트 규모가 그리 크지 않은데 상태 관리 도입으로 오히려 복잡해지진 않을까?<br/>
당연히 새로운 라이브러리 도입엔 시간이 소요됨<br/>
현재 인증 부분이 완벽하지 않을 뿐더러 작은 규모라 오히려 도입에 소요되는 시간이 적다고 판단<br/>
그리고 인증 관련 로직이 이미 복잡해서 정리할 필요성 O<br/>
정리하는 것이 필요하다고 판단<br/>

### 그래서 어떤거 사용?

리액트 상태관리 라이브러리는 대표적으로 아래와 같음
| 라이브러리 | 특징 | 장점 | 단점 | 적합한 경우 |
| --------------- | ---------------------------------- | -------------------------------------------------------------------- | --------------------------------------- | -------------------------------- |
| **Context API** | React 내장 전역 상태 | - 외부 설치 불필요<br>- 간단한 구조<br>- 공식 API | - 리렌더링 성능 이슈<br>- 상태 분리 어려움<br>- 디버깅 불편 | 간단한 테마, 언어, 로그인 상태 등 매우 작은 전역 상태 |
| **Zustand** | 함수 기반 전역 상태 관리 | - 러닝커브 낮음<br>- 코드 간결<br>- 성능 우수<br>- 미들웨어 다양 (`persist`, `devtools`) | - 구조화 강제 없음<br>- 대규모 팀에서 패턴 통일 필요 | 작고 중간 규모의 프로젝트, 빠르게 구조 잡고 싶은 경우 |
| **Recoil** | 페이스북이 만든 상태관리<br>atom, selector 개념 | - 비동기/파생 상태 쉽게 관리<br>- 구조화 잘됨<br>- 리액트 친화적 | - 아직 정식 릴리즈 X (2025 기준 베타)<br>- 커뮤니티 작음 | 중간\~대형 규모, 비동기 파생 상태가 많은 경우 |
| **Redux** | 대표적 상태관리 라이브러리 (Flux 구조) | - 구조가 명확<br>- 확장성 뛰어남<br>- Redux Devtools, 미들웨어 다양 | - 보일러플레이트 많음<br>- 러닝커브 있음 | 대규모 앱, 상태 흐름을 명확하게 제어해야 하는 경우 |

1순위로 고려할 점은 러닝커브<br/>
프로젝트 일정이 촉박하기 때문에 빠르게 도입이 가능해야함<br/>

2순위는 가벼움, 간결함<br/>
프로젝트 규모가 크지 않은데 복잡해지지는 않을까? 라고 생각했었기 때문에<br/>
초기 설정이 간단해야함<br/>
그리고 이미 작성한 코드들이 있기 때문에 라이브러리를 도입하면서 기존 코드 재작성이 많아지면 안됨

👉 따라서 zustand 채택

- 낮은 러닝커브
- 설치만하면 바로 사용 가능
- 사용 경험이 있는 vue의 pinia와 비슷한 구조

- Zustand를 메모리 기반 상태 관리이기 때문에 토큰을 메모리에 저장하고 관리함
  - 이전에 토큰을 localStorage에 저장하는 방식의 보안 이슈에 대해 논의한 경험 O
  - 따라서 이 부분도 함께 해소 가능

### 결론

지금 상태에서 Zustand를 도입하면

- 로그인 상태 안정적 관리 가능
- 인증 관련 로직의 복잡도를 줄일 수 있다고 판단
