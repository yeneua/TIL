### 기술 스택 선정 이전에… 우리 프로젝트는

1. 규모

   1. 개발 일정
      - 2주~3주 정도
      - 페이지 수는 적음
   2. 개발 인원
      - 1.5명

1. 그래프 뷰 페이지

   - 옵시디언에 활용된 기술
     - **PIXI.js**: 그래프의 노드(노트)와 엣지(링크)를 화면에 그리는 데 사용되는 2D 렌더링 라이브러리입니다.
     - **WebGL**: PIXI.js는 내부적으로 WebGL을 활용하여 하드웨어 가속을 통해 수천 개의 노드도 빠르고 부드럽게 렌더링할 수 있습니다. 초기에는 SVG 방식도 고려되었으나, 대규모 그래프에서의 성능 문제로 WebGL 기반의 PIXI.js가 채택되었습니다.
     - **D3.js**: 그래프의 노드들이 서로 밀고 당기며 적절한 위치를 찾아가도록 하는 '물리 기반 레이아웃(force-directed layout)' 시뮬레이션에 D3.js 라이브러리가 사용됩니다.
       요약하자면, **D3.js**로 노드의 위치를 계산하고, **PIXI.js**와 **WebGL**을 이용해 이를 고성능으로 화면에 그려내는 방식입니다.

   **생각해야할 부분**

   ⇒ 렌더링, 상호작용(interaction)

   1. 초기 렌더링 속도
   2. DOM 조작 최소화 → 매 프레임마다 화면 부드럽게 갱신하기 위해서
   3. 상호 작용 반응성

## SSR + Lazy Loading

### 왜 SSR인지??

- 빠른 초기 속도 고려

### SSR에서 그래프 뷰 그리기

- 지식맵 그리는 D3.js, PIXI.js 시각화 라이브러리는 SSR로 처리 불가
- **브라우저 API 의존성**
  - `<canvas>`, `window` 객체 사용 ← 브라우저 환경에만 존재하는 API 사용
  - 서버 Node.js로는 사용 불가
- **데이터 의존성**
  - 사용자가 노트 작성하면 데이터가 실시간으로 바뀔 수 있음
  - 서버가 미리 그려주는 건 불가능함

⇒ SSR 사용하더라도 지식맵 영역은 클라이언트에서 렌더링 해야함

### SSR + Lazy Loading

- 전체 레이아웃은 SSR로 빠르게 렌더링
- 지식맵 - Lazy Loading으로 로딩
  - 빠른 TTI

### 그런데 왜 Next?

- SSR 지원
- 동적 임포트
  - 지식맵 컴포넌트 lazy loading
  - ssr 비활성화 옵션 有 : 브라우저 API에 의존하는 라이브러리 연동 쉬움

## 상태 관리

### 전역 상태 관리

> Zustand

### 서버 상태 관리

> TanStack Query

## CSS

tailwind

- 다크모드 지원해야된다고 생각해서

<hr/>

# 기술 스택 선정 이유

## CSR vs SSR

기술스택 선정에 있어 최초에 고민한 것은 바로 렌더링 방식이다. 서비스 특성상 노드 그래프 형식으로 메인페이지에 UI를 표현해주어야 하다보니 고도의 인터렉티브한 UI가 필요하다. 물론 SSR + CSR 하이브리드 형식으로 Next.js를 사용하는 것에 대해서 고민하고 탐구해보았지만, 사실 우리 서비스는 개인화된 데이터만 다룰 예정이다 보니 SEO를 고려할 필요가 없다고 판단하여, CSR이 적합하다고 최종 판단했다.

위와 같은 사고 과정을 통해 CSR의 대표적인 세트 기술스택인 React + TypeScript + Vite을 사용하기로 결정했다. Vite는 번들링 최적화와 코드 스플리팅을 지원할뿐더러 역시 React로 개발한 크롬 확장프로그램 빌드 설정이 용이하기 때문에 React + TS + Vite는 CSR 생태계 기준으로 절대적인 것 같다.

## React v18

생태계가 압도적으로 넓다는 점에서 이견은 없었다. React 생태계 내부에서 정말 다양한 블록 에디터/그래프 라이브러리가 존재하기 때문에 React를 사용하지 않을 이유는 딱히 없다고 생각한다. 라이브러리를 사용할때 기술부채 측면만 고려해보면 될 것 같다. 하지만 버전을 선택하는 부분에서는 충분한 고민이 필요했다. React v19가 출시된 시점에서 React v19에서 제공하는 훅 중 하나인 Optimistic UI 관련 훅을 사용하는 것이 좋을지 고민이 되었다. 사실 노션 + 옵시디언과 유사한 서비스를 기본적으로 탑재하다보니 낙관적 UI가 필수이지 않을까 생각했다. 하지만 그럼에도 불구하고 아직 React v19가 안정화되었다고 판단하지 않을뿐더러 잠재적으로 React와 호환되는 타 라이브러리들과의 버전 호환성 문제를 안고 가기에는 리스크가 크다고 판단하여 React v18를 선택하기로 했다.

## Tailwind CSS + Shadcn UI

애초에 Shadcn UI가 Tailwind 기반이다. 커스터마이징 자유도 높은 Shadcn은 빠른 프로토타이핑을 개발하기에 개발속도와 효율측면에서 굉장한 이점이 있다고 본다. 실제 경험상 특화 때 개발기간을 한 주 남겨 놓고 프론트엔드 개발을 시작하였는데 Shadcn에 이미 정의되어 있는 컴포넌트들을 사용하니 일관된 디자인 컴포넌트 개발시간을 획기적으로 줄일 수 있었다. 다크모드 역시 기본적으로 지원이 되기 때문에 사용자의 여러가지 테마모드를 지원하기에도 적합할 것이다 판단하여 사용하기로 결정하였다. 결론은 빠른 MVP 개발 목적

## Tiptap v2

2025년 기준 블록 에디터 구현에 가장 많이 언급된 라이브러리라고 한다. 실제 개발자들의 후기를 확인해보면 Notion 스타일 블록 에디터 구현에 최적되어 있다고 한다. 마크다운 완벽 지원은 물론 유료 서비스를 이용하면 노션처럼 협업 기능 추가가 가능하다고 한다. 물론 우리 서비스는 협업 기능은 없기 때문에 해당 기능은 고려사항에 해당하지 않지만 무료 오픈소스에서 제공되는 노션 스타일 블록 에디터 기능이 강력하다는 점에서 굉장한 메리트가 있다고 판단했다. 이 역시 빠른 MVP 개발을 위해 채택하였다.

<aside>
📌

> 대안으로 Editor.js / BlockNote

</aside>

## 그래프 시각화

그래프 시각화를 위한 라이브러리는 React Flow, D3 등 다양하게 존재하지만, 아직 충분히 탐구하지 못했다.

## Zustand

Zustand가 크롬 확장프로그램과 상태 공유가 용이하다는 글을 다수 발견하여 선택하였다. 물론 노션과 같은 기능에서 리렌더링이 자주 발생할 수 있기 때문에 Jotai를 고민해보았지만 Optimistic Updates를 생각하면 atomic하게 상태관리를 할 필요가 없다고 판단했으므로 DevTools를 지원해주는 Zustand를 선택했다.

## TanStack Query v5

고도의 인터렉티브 UI를 구현할 우리 서비스에서 자동 캐싱과 백그라운드 리페치는 필수라고 생각한다. 더군다나 Optimistic Updates로 즉각적인 UI 반응과 에로/로딩 상태 관리 자동화에 가장 강력한 라이브러리는 아직 TanStack Query를 넘볼 수 있는 툴을 찾을 수 없었다. Neo4j 쿼리 결과 캐싱에도 유용하기 때문에 필수라고 생각하는 것에 이견이 없었다.

## 추가 라이브러리

- framer-motion : 부드러운 애니메이션
- date-fns : 리마인드 알림 시간 계산
- react-hot-toast : 알림 메시지
- tanstack/react-virtual: 대량 노트 목록 가상화
  - 그래프를 보여준다고 가정할 때 화면에 보이는 부분만 실시간 렌더링을 최적화 해주기 위해서 필요하다고 판단
